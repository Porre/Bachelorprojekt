\chapter{Faktoriseringsalgoritmer}

I dette kapitel ønsker vi at se på faktoriseringsalgoritmer. Det viser sig nemlig, at en af de anvendelser som elliptiske kurver besidder, er indenfor faktoriseringen af heltal. Faktoriseringsproblemet, altså hvordan man bestemmer en faktor for et tal $n$ er yderst relevant, da alle heltal kan faktoriseres:

\begin{theorem}[Aritmetikkens fundamentalsætning]
Et heltal $n > 1$ kan faktoriseres entydigt som et produkt af primtal, så hvis
\begin{align*}
	p_1 \cdot p_2 \cdot \ldots \cdot p_k = q_1 \cdot q_2 \cdot \ldots \cdot q_,
\end{align*}
hvor $p_i$ og $q_j$ er primtal for $1 \leq i \leq k$ og $1 \leq j \leq l$ er $k = l$ og $p_i = q_i$ for alle $i=1, 2, \ldots, k$ (efter eventuelle ombytninger). Desuden er faktorerne $p_{1}^{n_1}, p_{2}^{n_2}, \ldots, p_{k}^{n_k}$ entydigt bestemte.
\end{theorem}

For et bevis af sætningen se f.eks. \cite{Hansen}. Det vigtige at bemærke er, at beviset ikke er konstruktivt og dermed ikke giver os en måde, hvorpå vi kan finde disse faktorer. Men hvordan kan vi så finde disse faktorer, som vi nu ved findes? Hvis vi har et sammensat tal $n$, som vi ønsker at faktorisere kunne vi angribe problemet med en naiv tilgang. Vi antager for nemhedens skyld at $n = pq$, hvilket gør det klart at $\min \{p, q \} \leq \sqrt{n}$. Vi kan altså finde en faktor ved at undersøge om først $2 \mid n$, dernæst om $3 \mid n$ osv. indtil at vi finder en faktor, hvilket vil ske senest når vi når til $\sqrt{n}$. Denne løsning er fin for tilstrækkeligt små tal, men det bliver hurtigt uoverkommeligt for store tal (eksempler på hvor lang tid det tager?). 

Sikkerheden i moderne kryptosystemer hviler på dette faktum, at det tager lang tid at faktorisere et heltal. Derfor er det interessant at undersøge om man gøre det hurtigere end den med den naive tilgang. Vi skal se på to af sådanne algoritmer, nemlig Pollards $p-1$ algoritme og Lenstras algoritme, som benytter elliptiske kurver til at finde en faktor.

\section{Pollards $p-1$ algoritme}

Vi starter med at se på Pollards $p-1$ algoritme, da Lenstras algoritme er stærkt inspireret af denne og delvist kan ses som en analog til den, hvilket gør det naturligt at betragte den først. Pollards $p-1$ algoritme blev først præsenteret i \cite{Pollard} i 1970'erne af J. M. Pollard. Algoritmen hviler på Fermats lille sætning:

\begin{theorem}[Fermats lille sætning]
\label{fermats_small_theorem}
Lad $p$ være et primtal som ikke går op i $a$. Da gælder der, at
\begin{align*}
	a^{p-1} = 1 \modu{p}.
\end{align*}
\end{theorem}

\noindent Et bevis findes i appendikset.

Vi kan da se på, hvordan Pollards $p-1$ algoritme virker. Lad $n$ være et sammensat tal og lad $p$ være en primfaktor for $n$. Vi ved fra Fermats lille sætning, at $a^{p-1} \equiv 1 \modu{p}$ når $\gcd(a, p) = 1$. Hvis vi da kendte $p-1$ kunne vi bestemme $p$ (udover den åbenlyse måde) ved
\begin{align*}
	\gcd(a^{p-1} - 1, n) = p. 
\end{align*}
(måske et multiplum af $p$?), da hvis $x \equiv 1 \modu{l}$, hvor $l$ er en faktor i $n$, er $\gcd(x-1, n)$ divisibel med denne faktor $l$.

Vi kender dog ikke $p-1$ og vi kan derfor ikke foretage denne udregning. Det viser sig dog, at vi kan nøjes med et multiplum af $p-1$, da
\begin{align*}
	a^{t(p-1)} - 1 = (a^{p-1})^k - 1 \equiv 1^k - 1 \equiv 0 \modu{p}.
\end{align*}
Idéen er da, at vi vælger et heltal
\begin{align*}
	k = 2^{e_2} \cdot 3^{e_3} \cdot 5^{e_5} \cdots r^{e_r},
\end{align*}
hvor $2, 3, \ldots, r$ er primtal og $e_1, e_2, \ldots, e_r$ er små positive heltal. Vi udregner da $\gcd(a^k - 1, n)$. Hvis vi er i det heldige tilfælde, hvor $n$ har en faktor sådan, at $p-1 \mid k$, da vil $p \mid a^k - 1$ og
vi har så, at
\begin{align*}
	\gcd(a^k - 1, n) \geq p > 1.
\end{align*}
Hvis $\gcd(a^k - 1, n) \neq n$ har vi altså fundet en ikke-triviel faktor for $n$ og vi kan dele $n$ i to faktorer og gentage de ovenstående trin. Hvis vi derimod har, at $\gcd(a^k -1, n) = n$ vælger vi et andet $a$ og forsøger igen, og hvis $\gcd(a^k-1,n)=1$ vælger vi et større $k$.

Dette er tankegangen i Pollards $p-1$ algoritme og vi opsummerer det i algoritmen:

\begin{algorithm}[Pollards $p-1$ algoritme]
Lad $n \geq 2$ være et sammensat tal, som er tallet vi ønsker at 
finde en faktor for.
\begin{enumerate}
	\item Vælg $k \in \mathbb{Z}^+$ sådan, at $k$ er et produkt
	af mange små primtal opløftet i små potenser. Eksempelvis kan $k$ vælges til at være
	\begin{align*}
		k = \lcm [1, 2, \ldots, K],
	\end{align*}
	for et $K \in \mathbb{Z}^+$ og hvor $\lcm$ er det mindste fælles multiplum.
	\item Vælg et heltal $a$ sådan, at $1 < a <n$.
	\item Udregn $\gcd(a, n)$. Hvis $\gcd(a, n) > 1$ har vi fundet en
	ikke-triviel faktor for $n$ og vi er færdige. Ellers fortsæt til næste
	trin.
	\item Udregn $D = \gcd(a^k - 1, n)$. Hvis $1 < D < n$ er $D$ en ikke-triviel
	faktor for $n$ og vi er færdige. Hvis $D = 1$ gå da tilbage til trin 1
	og vælg et større $k$. Hvis $D = n$ gå da til trin 2 og vælg et nyt $a$. 
\end{enumerate}
\end{algorithm}

Følgende er et eksempel på anvendelsen af Pollards algoritme,
hvor det går godt, altså hvor $p-1$ har små primfaktorer:

\begin{example}
Vi vil forsøge at faktorisere 
\begin{align*}
	n = 30042491.
\end{align*}
Vi ser at $2^{n-1} = 2^{30042490} \equiv 25171326 \ (\textrm{mod}\ 30042491)$,
så $N$ er ikke et primtal. Vi vælger som beskrevet i algoritmen
\begin{align*}
	a = 2 \quad \text{og} \quad k = \mathrm{LCM}[1,2, \ldots, 7] = 420.
\end{align*}
Da $420 = 2^2 + 2^5 + 2^7 + 2^8$ skal vi udregne $2^{2^i}$ for 
$0 \leq i \leq 8$. Dette resulterer i følgende tabel:

\begin{center}
\begin{tabular}{c c c c}
$i$ & $2^{2^i} \modu{n}$ & & \\ 
\hline 
1 & 4 & 5 & 28933574 \\ 
2 & 16 & 6 & 27713768 \\ 
3 & 256 & 7 & 10802810 \\ 
4 & 65536 & 8 & 16714289 \\ 
5 & 28933574 & & 
\end{tabular} 
\end{center}

Denne tabel gør det forholdsvist let for os, at bestemme
\begin{align*}
	2^{420} &= 2^{2^2 + 2^5 + 2^7 + 2^8} \\
	&\equiv 16 \cdot 28933574 \cdot 10802810 \cdot 16714289
	\modu{30042491} \\
	&\equiv 27976515 \modu{30042491}.
\end{align*}

Ved anvendelse af den euklidiske algoritme finder vi dernæst, at
\begin{align*}
	\mathrm{gcd}(2^{420} - 1 \modu{n}, n) = \mathrm{gcd}(27976514, 30042491) = 1.
\end{align*}
Her fejler testen altså og vi er nået frem til, at $N$ ikke har nogle 
primtalsfaktorer $p$ sådan, at $p-1$ deler $420$. Algoritmen foreskriver da, at vi skal vælge et nyt $k$. Vi lader
\begin{align*}
	k = \mathrm{LCM}[1,2, \ldots, 11] = 27720.
\end{align*}
Da $27720 = 2^{14} + 2^{13} + 2^{11} + 2^{10} + 2^{6} + 2^3$ skal vi udvide tabellen til at indeholde værdierne for $2^{2^i}$ for $0 \leq i \leq 14$:

\begin{center}
\begin{tabular}{c c c c}
$i$ & $2^{2^i} \modu{n}$ & &  \\ 
\hline 
9 & 19694714 & 12 & 26818902 \\ 
10 & 3779241 & 13 & 8658967 \\ 
11 & 11677316 & 14 & 3783587 \\ 
\end{tabular} 
\end{center}

Vi fortsætter på samme måde, som vi gjorde før og bestemmer
\begin{align*}
	2^{27720} &= 2^{2^3 + 2^{2^6} + 2^{2^{10}} + 2^{2^{11}} + 2^{2^{13}} + 2^{2^{14}}} \\
	&= 256 \cdot 27713768 \cdot 3779241 \cdot 11677316 \cdot 8658967 \cdot 3783587 \\
	&= 16458222 \modu{30042491}.
\end{align*}
Vi finder dernæst, at
\begin{align*}
	\gcd(2^{27720} - 1 \modu{n}, n) = \gcd(16458221, 30042491) = 9241,
\end{align*}
hvilket betyder at vi har fundet en ikke-triviel faktor for $n$. Mere præcist har vi fundet faktoriseringen
\begin{align*}
	30042491 = 3251 \cdot 9241.
\end{align*}

\end{example}